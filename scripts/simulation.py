# -*- coding: utf-8 -*-
"""Untitled0.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1eUKqnW5xQ-2xTw_9h3OAynLwCHpwbVz-
"""

import matplotlib.pyplot as plt
import numpy as np
import pandas as pd

import numpy.random as rnd
import scipy.optimize as opt

debug_enabled = True
debug_level = 2

def debug_msg(msg, placeholders=None, level=1):
  global debug_enabled
  global debug_level

  if debug_enabled and level <= debug_level:
    if placeholders is not None:
      print(msg % placeholders)
    else:
      print(msg)

def choice_without_rep(sample_set, sample_size):
  res = []
  for i in range(0, sample_size):
    s = rnd.choice(sample_set, 1)
    res.append(s[0])
    sample_set.remove(s)
  res.sort()
  return res

def eggholder(x):
  z =  -(x[0] + 47) * np.sin(np.sqrt(np.abs(x[1] + (x[0]/2.0) + 47)))- x[0] * np.sin(np.sqrt(np.abs(x[0] - (x[1]+ 47))))
  return z

def eggholder_rw(x):
  z =  -(x[:, 0] + 47) * np.sin(np.sqrt(np.abs(x[:, 1] + (x[:, 0]/2.0) + 47)))- x[:, 0] * np.sin(np.sqrt(np.abs(x[:, 0] - (x[:, 1]+ 47))))
  return z


def contour_eggholder(X,Y):
  Z =  -(Y + 47) * np.sin(np.sqrt(np.abs(Y + (X/2.0) + 47)))- X * np.sin(np.sqrt(np.abs(X - (Y + 47))))
  return Z

def generate_points(n, dim, limits):
  points = rnd.random([n, dim])

  points = points * (limits[1] - limits[0]) + limits[0]
  return points

def plot_points(figure, points, color):
  x = np.linspace(-600, 600, 30)
  y = np.linspace(-600, 600, 30)
  X, Y = np.meshgrid(x, y)
  Z = contour_eggholder(X, Y)
  figure.contour(X, Y, Z, colors='black', linewidths=1)

  for p in points:
    figure.scatter(*p, c=color)

def optimize(points, bounds):
  opt_points = []
  opt_values = []

  for point in points:
    res = opt.dual_annealing(eggholder, x0=point, bounds=bounds, maxiter=100)
    opt_points.append(res.x)
    opt_values.append(res.fun)

  return opt_points, opt_values

def variation_rate(region):
  sample = [eggholder(x) for x in region]
  return np.std(sample, ddof=1) / np.mean(sample)

def global_variation_rate(regions):
  sample = []
  for _, region in regions:
    for s in region:
      sample.append(eggholder(s))

  return np.std(sample, ddof=1) / np.mean(sample)

def create_k_regions(k, points):
  indexes = np.array(range(1, len(points) - 1))
  intervals = rnd.choice(indexes, size=k - 1, replace=False)
  intervals = np.sort(intervals)
  regions = dict()
  begin = 0
  end=len(points)
  for i in intervals:
    regions[begin] = points[begin:i]
    begin = i
  regions[begin] = points[begin:end]

  return regions

def can_merge(regions, region_a_idx, region_b_idx, min_regions=3):
  if len(regions) == min_regions:
    return False

  merged = []
  for x in regions[region_a_idx]:
    merged.append(x)
  for x in regions[region_b_idx]:
    merged.append(x)

  a_var = np.var(regions[region_a_idx])
  b_var = np.var(regions[region_b_idx])
  merged_var = np.var(merged)

  return merged_var < a_var or merged_var < b_var

def merge(regions, region_a_idx, region_b_idx):
  if not can_merge(regions, region_a_idx, region_b_idx):
    return regions, False

  res = regions
  region_a = res[region_a_idx]
  region_b = res[region_b_idx]

  print("Region a: %s " % region_a)
  print("Region b: %s " % region_a)

  res.pop(region_a_idx)
  res.pop(region_b_idx - 1)
  region_a.extend(region_b)
  res.append(region_a)
  return res, True

def can_split(regions, min_solutions=90):
  return [i for i in regions.keys() if variation_rate(regions[i]) > global_variation_rate(regions) and len(regions[i]) > min_solutions]

def split(regions, region_idx, max_regions=10):
  ans = regions
  region = ans[region_idx]

  if len(regions) > max_regions:
    return regions, False

  ans.pop(region_idx)

  left = []
  right = []
  center = []

  mean = np.mean(region)
  std = np.mean(region)

  for solution in region:
    fun = eggholder(solution)

    if fun < mean - std:
      left.append(solution)
    elif fun > mean + std:
      right.append(solution)
    else:
      center.append(solution)

  ans.append(left)
  ans.append(center)
  ans.append(right)

  return ans, True

def simulate(iterations, n_regions, n_points, limits=[-500.0, 500.0], dim=2):

  points = generate_points(n_points, dim, limits)
  opt_limits = [limits for x in range(0, dim)]
  optimized_points, values = optimize(points, opt_limits)
  regions = create_k_regions(n_regions, optimized_points)
  region_metrics = []
  global_metrics = []
  regions_count = []
  merge_count = []
  split_count = []
  debug_msg("Regions at t0: %s", (regions), level=2)

  for i in range(0, iterations):
    debug_msg("#%d iteration", (i))
    debug_msg("no. of regions: %d", (len(regions)), level=3)
    region_var_rate = [variation_rate(r) for r in regions.values()]
    debug_msg("region variation rates: %s", (region_var_rate), level=3)
    # generate a new point and optimize it
    # TODO it could also get an existing point from the system and improve it
    new_point = generate_points(1, dim, limits)
    optimized_new_point, _ = optimize(new_point, opt_limits)

    rnd_region = choice_without_rep(list(regions.keys()), 1)[0]

    regions[rnd_region].append(optimized_new_point[0])

    merge_or_split = rnd.random()

    if merge_or_split < 0.5:
      regions_idx = regions.keys()
      region_idx = choice_without_rep(regions_idx, 2)
      region_a, region_b = region_idx[0], region_idx[1]
      debug_msg("Trying to merge regions %d and %d", (region_a, region_b), level=2)
      regions, did_merge = merge(regions, region_a, region_b)
      merge_count.append(did_merge)
    else:
      regions_can_split = can_split(regions)
      if len(regions_can_split) > 0:
        region_idx = rnd.choice(regions_can_split, 1)[0]
        debug_msg("Trying to split region %d with %d solutions", (region_idx, len(regions[region_idx])), level=2)
        regions, did_split = split(regions, region_idx)
        split_count.append(did_split)

    n_regions = len(regions)

    it_metrics = [variation_rate(region) for region in regions]

    region_metrics.append(it_metrics)
    global_metrics.append(global_variation_rate(regions))
    regions_count.append(len(regions))

  return regions_count, region_metrics, global_metrics, merge_count, split_count

n_points = 100
dim = 2
limits = [-500.0, 500.0]
n_regions = 5
points = generate_points(n_points, dim, limits)
opt_limits = [limits for x in range(0, dim)]
optimized_points, values = optimize(points, opt_limits)
regions = create_k_regions(n_regions, optimized_points)

print(regions)

#regions_count, region_metrics, global_metrics, merge_count, split_count = simulate(1000, 5, 100)

#plt.plot(region_metrics)
#plt.plot(global_metrics, 'r-x')
#plt.show()

#print(merge_count)
#print(split_count)